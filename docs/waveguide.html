<!DOCTYPE HTML>
<html>
<head>
    <title>Wayverb - Waveguide</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="shortcut icon" type="image/x-icon" href="/wayverb/assets/favicon.ico" />
	<!--[if lte IE 8]><script src="/wayverb/assets/js/ie/html5shiv.js"></script><![endif]-->
	<link rel="stylesheet" href="/wayverb/assets/css/main.css" />
    <link rel="stylesheet" href="/wayverb/assets/css/font-awesome.min.css" />
	<!--[if lte IE 9]><link rel="stylesheet" href="/wayverb/assets/css/ie9.css" /><![endif]-->
	<!--[if lte IE 8]><link rel="stylesheet" href="/wayverb/assets/css/ie8.css" /><![endif]-->

<!-- Scripts -->
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
</head>

<body>
<nav id="sidebar_nav">
    <a href="/wayverb/" class="title">Wayverb</a>
    <ul>
        
        
            <li>
                <a href="/wayverb/introduction.html" >
                    Introduction
                </a>
            </li>
        
            <li>
                <a href="/wayverb/context.html" >
                    Context
                </a>
            </li>
        
            <li>
                <a href="/wayverb/theory.html" >
                    Theory
                </a>
            </li>
        
            <li>
                <a href="/wayverb/image_source.html" >
                    Image-source Model
                </a>
            </li>
        
            <li>
                <a href="/wayverb/ray_tracer.html" >
                    Ray tracer
                </a>
            </li>
        
            <li>
                <a href="/wayverb/waveguide.html" class="active">
                    Waveguide
                </a>
            </li>
        
            <li>
                <a href="/wayverb/hybrid.html" >
                    Hybrid Model
                </a>
            </li>
        
            <li>
                <a href="/wayverb/microphone.html" >
                    Microphone modelling
                </a>
            </li>
        
            <li>
                <a href="/wayverb/boundary.html" >
                    Boundary modelling
                </a>
            </li>
        
            <li>
                <a href="/wayverb/evaluation.html" >
                    Evaluation
                </a>
            </li>
        
            <li>
                <a href="/wayverb/conclusion.html" >
                    Conclusion
                </a>
            </li>
        
    </ul>
</nav>

<div id="page_main">
    <header>
        <ul>
            <li class="nav_menu open" >
                <a href="#sidebar_nav">
                    &#9776;
                </a>
            </li>
            <li class="nav_menu close" >
                <a href="#">
                    &#9776;
                </a>
            </li>
            <li>
                <a href="/wayverb/" >
                    Wayverb
                </a>
            </li>
        </ul>
    </header>
    <div class="inner">
        <nav id="prev_next_nav">
    
    
        
    
        
    
        
    
        
    
        
    
        
            
            
            
                <a href="/wayverb/ray_tracer.html" class="prev_page">Ray tracer</a>
            

            
            
            
                <a href="/wayverb/hybrid.html" class="next_page">Hybrid Model</a>
            
        
    
        
    
        
    
        
    
        
    
        
    
</nav>

        <div id="TOC">
<ul>
<li><a href="#digital-waveguide-mesh">Digital Waveguide Mesh</a><ul>
<li><a href="#background">Background</a><ul>
<li><a href="#method">Method</a></li>
<li><a href="#strengths-and-weaknesses-of-the-dwm">Strengths and Weaknesses of the DWM</a></li>
</ul></li>
<li><a href="#design-choices">Design Choices</a><ul>
<li><a href="#mesh-topology">Mesh Topology</a></li>
<li><a href="#source-excitation-method">Source Excitation Method</a></li>
</ul></li>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#inner-and-outer-nodes">Inner and Outer Nodes</a></li>
<li><a href="#boundary-node-classification">Boundary Node Classification</a></li>
<li><a href="#boundary-behaviour-and-materials">Boundary Behaviour and Materials</a></li>
<li><a href="#running-the-simulation">Running the Simulation</a></li>
</ul></li>
<li><a href="#summary">Summary</a></li>
</ul></li>
<li><a href="#bibliography">References</a></li>
</ul>
</div>
<h1 id="digital-waveguide-mesh" class="major">Digital Waveguide Mesh</h1>
<h2 id="background">Background</h2>
<p>The <em>digital waveguide mesh</em> (DWM) is one of several wave-based simulation techniques. Each technique in this family is derived directly from the wave equation, allowing them to inherently support wave phenomena such as diffraction and interference. Wave effects such as these have a great effect upon the low-frequency response of a room. This means that at low frequencies wave-based methods are far more accurate than geometric methods, which are not able to model wave effects <span class="citation" data-cites="southern_spatial_2011">[<a href="#ref-southern_spatial_2011">1</a>]</span>.</p>
<p>The drawback of wave-based methods is that their computational complexity increases rapidly with the maximum output frequency, and with the volume of the modelled space. A waveguide simulation of a space with volume <span class="math inline">\(V\)</span>, at sampling frequency <span class="math inline">\(f_s\)</span>, will have a complexity of <span class="math inline">\(O(V f_s^3)\)</span>. This means that, on current consumer hardware, it is not feasible to compute a full-spectrum simulation using wave-based techniques. The hybrid simulation method implemented in Wayverb aims to optimise computation time, while retaining reasonable accuracy across the spectrum, by combining wave-based methods with geometric methods. Wave-based methods are used to calculate accurate low-frequency content, while geometric methods estimate the higher frequency content, which is less dependent upon wave effects.</p>
<p>There are, largely speaking, two main types of wave-based simulation used for room acoustics: element methods, and finite difference methods. The waveguide mesh is the latter, a simplified sub-class of the <em>finite-difference time-domain</em> (FDTD) technique. Although the DWM and FDTD have converged over time, and are equivalent <span class="citation" data-cites="smith_iii_equivalence_2004 karjalainen_digital_2004">[<a href="#ref-smith_iii_equivalence_2004">2</a>], [<a href="#ref-karjalainen_digital_2004">3</a>]</span>, their histories are quite different. The DWM was designed to be efficient for small-scale acoustic simulations in which the only quantity of interest is pressure <span class="citation" data-cites="smith_physical_1992">[<a href="#ref-smith_physical_1992">4</a>]</span>, while FDTD is a more general technique designed for electromagnetic simulation, in which the electric and magnetic fields are both of interest <span class="citation" data-cites="botts_integrating_2013">[<a href="#ref-botts_integrating_2013">5</a>]</span>.</p>
<h3 id="method">Method</h3>
<p>The derivation of the waveguide mesh begins with the one-dimensional <em>digital waveguide</em>. A one-dimensional waveguide can exactly describe the behaviour of a band-limited wave in one dimension. Such a model is well-suited for predicting the behaviour of certain musical instruments which use columns of air or vibrating strings to produce sound. The model itself is based on d’Alembert’s solution of the wave equation in one dimension <span class="citation" data-cites="shelley_diffuse_2007">[<a href="#ref-shelley_diffuse_2007">6</a>, p. 86]</span>. The displacement of a string <span class="math inline">\(y\)</span> at time <span class="math inline">\(t\)</span> and position <span class="math inline">\(x\)</span> can be written as</p>
<p><span style="display: inline-block; position: relative; width: 100%"><span class="math display">\[y(t,x)=y_r\left(t-\frac{x}{c}\right) + y_l\left(t+\frac{x}{c}\right)\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(1)</span></span> </p>
<p>where <span class="math inline">\(y_r\left(t-\frac{x}{c}\right)\)</span> and <span class="math inline">\(y_l\left(t+\frac{x}{c}\right)\)</span> are the right- and left-going travelling waves respectively, with speed <span class="math inline">\(c\)</span> <span class="citation" data-cites="smith_physical_1992">[<a href="#ref-smith_physical_1992">4</a>]</span>. The discrete form of this equation is given in terms of constant time and space divisions, <span class="math inline">\(T\)</span> and <span class="math inline">\(X\)</span> respectively:</p>
<p><span style="display: inline-block; position: relative; width: 100%"><span class="math display">\[y(nT,mX) \buildrel \Delta \over = y^+(n-m) + y^-(n+m)\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(2)</span></span> </p>
<p>where superscript <span class="math inline">\(+\)</span> and <span class="math inline">\(-\)</span> denote propagation to the right and left respectively, and <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> are integers, used to index the spatial and temporal sampling intervals <span class="citation" data-cites="smith_iii_equivalence_2004">[<a href="#ref-smith_iii_equivalence_2004">2</a>]</span>.</p>
<p>An implementation of these equations will take the form of two parallel delay lines, which propagate wave components in opposite directions. This is shown in fig. <a href="#fig:one_d_waveguide">1</a>. The “output” of the simulation, that is, the physical displacement of the modelled string over time, is found by adding the wave components in both delay lines at a single point.</p>
<figure>
<img src="images/one_d_waveguide.svg" alt="Figure 1: Delay lines cause wave components to be propagated along the string over time. The total displacement of the string is found by adding together values from the same point on each delay line." id="fig:one_d_waveguide" /><figcaption>Figure 1: Delay lines cause wave components to be propagated along the “string” over time. The total displacement of the string is found by adding together values from the same point on each delay line.</figcaption>
</figure>
<p>Waveguides in higher dimensions can be created in a straightforward manner, by connecting digital waveguide elements at a <em>scattering junction</em>. Wave components entering the junction are distributed amongst the waveguide elements, preserving energy and power according to Kirchoff’s power conservation laws <span class="citation" data-cites="shelley_diffuse_2007">[<a href="#ref-shelley_diffuse_2007">6</a>, p. 87]</span>. The sound pressure <span class="math inline">\(p_J\)</span> at a lossless scattering junction <span class="math inline">\(J\)</span> with <span class="math inline">\(N\)</span> connected elements or “ports” is the summed incoming components of all connected elements:</p>
<p><span style="display: inline-block; position: relative; width: 100%"><span class="math display">\[p_J=\frac{2\sum_{i=1}^{N}\frac{p_i^+}{Z_i}}{\sum_{i=1}^{N}\frac{1}{Z_i}}\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(3)</span></span> </p>
<p>where <span class="math inline">\(p_i\)</span> is the pressure in waveguide element <span class="math inline">\(i\)</span> and <span class="math inline">\(Z_i\)</span> is its associated impedance. This simplifies, if all impedances are equal, which is true for homogeneous media:</p>
<p><span style="display: inline-block; position: relative; width: 100%"><span class="math display">\[p_J=\frac{2}{N}\sum_{i=1}^{N}p_i^+\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(4)</span></span> </p>
<p>A <em>digital waveguide mesh</em> is any configuration of regularly-arranged <span class="math inline">\(N\)</span>-port scattering junctions which are separated by unit delay lines. In some literature, this specific type of mesh is known as a <em>W-DWM</em> because it operates in terms of “W” (wave) variables.</p>
<p>The input into a scattering junction is equal to the output of a neighbour junction at the previous time step. This fact allows the waveguide mesh to alternatively be formulated directly in terms of the pressure at each junction (assuming all junction impedances are equal) <span class="citation" data-cites="beeson_roomweaver:_2004">[<a href="#ref-beeson_roomweaver:_2004">7</a>]</span>:</p>
<p><span style="display: inline-block; position: relative; width: 100%"><span class="math display">\[p_J(n)=\frac{2}{N}\sum_{i=1}^{N}p_i(n-1)-p_J(n-2)\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(5)</span></span> </p>
<p>That is, the next pressure at a given node depends on the previous pressure at that node, and the current pressure at surrounding nodes. This alternative formulation operates on Kirchhoff variables, and is therefore known as a <em>K-DWM</em>. In the 1D case, the K-DWM and W-DWM are computationally identical <span class="citation" data-cites="smith_iii_equivalence_2004">[<a href="#ref-smith_iii_equivalence_2004">2</a>]</span>. In higher dimensions, they are equivalent only under certain circumstances <span class="citation" data-cites="murphy_acoustic_2007">[<a href="#ref-murphy_acoustic_2007">8</a>, p. 5]</span>.</p>
<p>The K-DWM is advantageous compared to the W-DWM for reasons of efficiency. It requires less memory, and fewer calculations per node per step than the W-DWM: experiments in <span class="citation" data-cites="beeson_roomweaver:_2004">[<a href="#ref-beeson_roomweaver:_2004">7</a>]</span> show that the K-DWM is 200% faster and uses 50% of the memory of the equivalent W-DWM. This is mainly to do with the number of values stored per node. Each node in a K-DWM must store a “current” and a “previous” pressure value, whereas in a W-DWM each <em>connection</em> must store a value <span class="citation" data-cites="karjalainen_digital_2004">[<a href="#ref-karjalainen_digital_2004">3</a>]</span>. For mesh layouts in which each node has many neighbours (see <a href="#mesh-topology">Mesh Topology</a> below), the W-DWM can require many times more memory. The K-DWM also requires one fewer addition per node per step <span class="citation" data-cites="shelley_diffuse_2007">[<a href="#ref-shelley_diffuse_2007">6</a>, p. 91]</span>, so will be slightly faster, all else being equal.</p>
<p>In the general case of an <span class="math inline">\(N\)</span>-dimensional waveguide mesh, the spatial and temporal sampling periods are related by the Courant number <span class="math inline">\(\lambda\)</span>. The Courant criterion specifies the conditions required for numerical stability of the simulation:</p>
<p><span style="display: inline-block; position: relative; width: 100%"><span class="math display">\[\lambda=\frac{cT}{X} \leq \frac{1}{\sqrt{N}}\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(6)</span></span> </p>
<p>The highest sampling rate and lowest error is achieved by setting the Courant number to its maximum value <span class="citation" data-cites="sheaffer_fdtd/k-dwm_2010">[<a href="#ref-sheaffer_fdtd/k-dwm_2010">9</a>]</span>. This is normally desirable, and so the inequality above can be simplified:</p>
<p><span style="display: inline-block; position: relative; width: 100%"><span class="math display">\[T=\frac{X}{c\sqrt{N}}\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(7)</span></span> </p>
<p>Here, <span class="math inline">\(T\)</span> is the temporal sampling period, <span class="math inline">\(X\)</span> is the spatial sampling period, <span class="math inline">\(c\)</span> is the speed of sound and <span class="math inline">\(N\)</span> is the number of spatial dimensions.</p>
<p>A higher output sampling rate requires a smaller inter-nodal spacing and therefore more modelled points per-unit-volume, which in turn requires more memory and more calculations per time step.</p>
<p>An output signal created using a mesh with a sampling frequency <span class="math inline">\(f_s = 1/T\)</span> has a maximum available bandwidth which spans from DC to the Nyquist frequency, <span class="math inline">\(0.5 \cdot f_s\)</span>. However, the <em>valid</em> bandwidth of the waveguide output is often considerably lower. For example, the highest valid frequency in the rectilinear mesh is <span class="math inline">\(0.196 \cdot f_s\)</span>. Detailed bandwidth information for other mesh topologies is given in <span class="citation" data-cites="kowalczyk_room_2011">[<a href="#ref-kowalczyk_room_2011">10</a>]</span>. The output signal will contain high-frequency content above the maximum valid frequency, however numerical dispersion in this region is so high that the results are completely non-physical. To ensure that the output only contains frequencies within the valid bandwidth, the invalid high frequency content must be removed using a low-pass filter at the output. Alternatively, the mesh may be excited using an input signal with no frequency content above the maximum valid frequency.</p>
<h3 id="strengths-and-weaknesses-of-the-dwm">Strengths and Weaknesses of the DWM</h3>
<p>The main advantage of the DWM is its relative simplicity. The air in the simulation is evenly divided into nodes. Each node has an associated pressure, and also stores its previous pressure. The next pressure at a node depends on its previous pressure, and the current pressures at its neighbours. The simulation progresses by repeatedly updating all nodes, and storing the change in pressure over time at some output nodes.</p>
<p>This simplicity presents an optimisation opportunity. Each node can be updated completely independently, as long as all updates in one time-step are completed before the next time-step begins. This means that the updates can happen in parallel. In fact, with enough memory and processing cores, the entire mesh could be updated in the time that it takes to update a single node. The update method is also very simple, only requiring some additions and a multiplication per node per step. This kind of simple, parallel code lends itself to implementations on graphics hardware, which is designed for running similar calculations simultaneously over large inputs. <em>Graphics processing units</em> (GPUs) have best throughput when all threads execute the same instruction, and when memory is accessed at consecutive addresses from running threads. The K-DWM update equation has no branching, and has consistent memory access patterns, which should allow for a very efficient implementation for GPUs.</p>
<p>The greatest limitation of the DWM is <em>dispersion error</em>. Unlike waves in homogeneous physical media, the velocity of wave propagation in the DWM depends on the direction of propagation, and also on the frequency of the wave component. This leads to errors in the frequency response of recorded signals, especially towards the upper limit of the output bandwidth. The exact pattern of dispersion error is dependent upon the topology of the mesh (topology is explained in the <a href="#mesh-topology">Mesh Topology</a> subsection), and can be examined using <em>Von Neumann</em> analysis <span class="citation" data-cites="van_duyne_3d_1996">[<a href="#ref-van_duyne_3d_1996">11</a>]</span>. One solution to the dispersion problem is to increase the sampling rate of the mesh, moving the high-error area out of the region of interest. Of course, this can quickly become very expensive, as the number of nodes, and therefore memory usage and computation time is proportional to the inverse cube of the sampling period. Another option is to use a mesh topology designed to reduce both direction- and frequency-dependent error, such as those presented in <span class="citation" data-cites="kowalczyk_room_2011">[<a href="#ref-kowalczyk_room_2011">10</a>]</span>. One interesting variation on this option is to reduce only direction-dependent error, and then to compensate for frequency-dependent error with a post-processing step, which is the approach taken in <span class="citation" data-cites="savioja_interpolated_2001">[<a href="#ref-savioja_interpolated_2001">12</a>]</span>. However, these mesh topologies with higher accuracy and isotropy require relatively high numbers of calculations per node. The interpolated schemes in <span class="citation" data-cites="kowalczyk_room_2011">[<a href="#ref-kowalczyk_room_2011">10</a>]</span> require 27 additions and 4 multiplications per node, whereas a tetrahedral mesh would require 5 additions and 1 multiplication. It is clear that high-accuracy results will be very costly to compute, whichever method is used.</p>
<!-- TODO how problematic are stepped boundaries? -->
<h2 id="design-choices">Design Choices</h2>
<h3 id="mesh-topology">Mesh Topology</h3>
<p>There is no single optimal implementation of the digital waveguide mesh. Perhaps the most important decision is the mesh topology or <em>stencil</em> that will be used, and by extension the mesh update equation. Here, the mesh topology refers to the pattern which is used to distribute nodes throughout the modelled space. The choice of topology will affect the accuracy, memory usage, calculation speed, and implementation complexity of the final design. It must therefore be chosen with care, in order to satisfy the constraints of the particular application.</p>
<p>The simplest topology is rectilinear, in which nodes are laid out on the vertices of a cubic grid, and each node has 6 direct neighbours. During the mesh update, the pressure at each neighbour node must be checked in order to calculate the next pressure at the current node. This is straightforward to implement, as the nodes can be stored in memory in a three-dimensional array, in which the array extents define the mesh dimensions, and the array indices refer to the positions of individual nodes. Other options for the topology include tetrahedral, octahedral, and dodecahedral, in which nodes have 4, 8, and 12 neighbours respectively, as shown in fig. <a href="#fig:topology">2</a>. In most of these meshes, the nodes align to a cubic grid in a straightforward manner. However, in the case of the tetrahedral mesh, the tessellation scheme is less obvious. The method used to construct the tetrahedral mesh is shown in detail in fig. <a href="#fig:tetrahedral_topology">3</a>.</p>
<figure>
<img src="images/topology.svg" alt="Figure 2: Some of the most common mesh topologies. Black lines show connections to nodes that will be checked during update. Note that the tetrahedral topology is unique, in that nodes can have two different orientations." id="fig:topology" /><figcaption>Figure 2: Some of the most common mesh topologies. Black lines show connections to nodes that will be checked during update. Note that the tetrahedral topology is unique, in that nodes can have two different orientations.</figcaption>
</figure>
<figure>
<img src="images/tetrahedral.svg" alt="Figure 3: Left: A single block of a tetrahedral mesh. Right: Individual blocks are combined in an alternating chessboard-like pattern to create a mesh with tetrahedral topology." id="fig:tetrahedral_topology" /><figcaption>Figure 3: <strong>Left:</strong> A single “block” of a tetrahedral mesh. <strong>Right:</strong> Individual blocks are combined in an alternating chessboard-like pattern to create a mesh with tetrahedral topology.</figcaption>
</figure>
<p>In their evaluation of different mesh topologies, Kowalczyk and Walstijn <span class="citation" data-cites="kowalczyk_room_2011">[<a href="#ref-kowalczyk_room_2011">10</a>]</span> define an accuracy criterion which can be used to compare topologies. This criterion is defined as the frequency band within which the maximum relative numerical error does not exceed 2%. They also describe how this “acceptably-accurate bandwidth” may be increased by overlaying or “superposing” rectilinear, octahedral, and dodecahedral schemes together. This is possible because all nodes are oriented uniformly, and have cubic tessellation. Such schemes are known as <em>interpolated</em>, and in these schemes each node has 26 neighbours. The rectilinear, octahedral, dodecahedral, and interpolated schemes may additionally all be represented by a single “unified” update equation, which is presented in <span class="citation" data-cites="kowalczyk_room_2011">[<a href="#ref-kowalczyk_room_2011">10</a>]</span>. In this respect the tetrahedral scheme is unique, requiring a dedicated update method. This is because the node connections in a tetrahedral mesh may be oriented in either of two directions, effectively requiring two update equations instead of one.</p>
<p>If the primary concern is speed rather than accuracy, a scheme with fewer neighbour nodes should be used, as the number of calculations per node is proportional to the number of neighbours <span class="citation" data-cites="campos_computational_2005">[<a href="#ref-campos_computational_2005">13</a>]</span>. The tetrahedral mesh has fewest neighbours per node, and also has the lowest density. That is, it requires the fewest nodes to fill a volume at any given sampling rate. Fewer nodes to update means fewer calculations, and a faster overall simulation. Lower density meshes also require less storage, so the tetrahedral scheme is the most time and memory efficient.</p>
<p>To optimise for accuracy, it appears that there are two possible approaches: The first option is to use an interpolated scheme, which is relatively inefficient in terms of time and space requirements, but which is most accurate for any given sampling rate. The second option is to use a tetrahedral mesh, which is inaccurate but the most time- and space-efficient, and to oversample until the required accuracy is achieved. Unfortunately, there is no prior research comparing the accuracy and efficiency of the tetrahedral topology against interpolated schemes. Due to time constraints, this could not be investigated as part of the Wayverb project (implementation and numerical analysis of mesh topologies is not trivial). It was, however, noted that the tetrahedral mesh is the more flexible of the two approaches. That is, when accuracy is not important, the tetrahedral mesh will always be most efficient, but it can be made more accurate by oversampling. On the other hand, the interpolated schemes cannot be tuned to produce less accurate results quickly - they will always be accurate but inefficient. For these reasons, the tetrahedral mesh was initially chosen for use in Wayverb.</p>
<p>The tetrahedral mesh was implemented during the first two months of the project, with support for microphone modelling. When it came to implementing frequency dependent boundary conditions, no prior research could be found discussing boundary implementations in a tetrahedral topology. As noted in the conclusion of <span class="citation" data-cites="kowalczyk_room_2011">[<a href="#ref-kowalczyk_room_2011">10</a>]</span>:</p>
<blockquote>
<p>One aspect that has not been dealt with in this paper, and could be of interest for future research, is the comparison of the identified schemes with the tetrahedral topology… However, the applicability of the tetrahedral stencil to room acoustic simulations is debatable due to the nontrivial formulation of boundary conditions for complex room shapes.</p>
</blockquote>
<p>The design of a new boundary formulation is outside the scope of this research, which was primarily concerned with the implementation of existing techniques rather than the derivation of new ones. Instead, the standard leapfrog (rectilinear) scheme was adopted at this point. Most of the tetrahedral code had to be rewritten, as the update schemes are very different (tetrahedral nodes have two possible update equations depending on node orientation), and the memory layout and indexing methods are more involved. The new scheme is much simpler than the tetrahedral mesh, and was quick to implement.</p>
<p>The rectilinear mesh uses the same cubic tessellation as the more complex topologies mentioned earlier, so in the future the update equation could conceivably be replaced with a more accurate “interpolated” alternative. Such a scheme would be more suitable than the rectilinear mesh for simulations where high accuracy is required. The conversion would only require changes to the update equations (and would complicate the boundary modelling code), but would be more straightforward than the move from the tetrahedral to the rectilinear topology. Due to time constraints, this was not possible during the project, meaning that the waveguide in Wayverb is not the most optimal in terms of accuracy <em>or</em> speed. Interpolated meshes are more accurate, and tetrahedral meshes are faster, although the rectilinear mesh is the fastest mesh with a cubic stencil. Instead, Wayverb’s waveguide was optimised for ease and speed of implementation. Use of a more suitable mesh topology would be a sensible starting point for future development work on the project.</p>
<h3 id="source-excitation-method">Source Excitation Method</h3>
<p>Input and output methods for the digital waveguide mesh are superficially simple. The waveguide mesh is a physical model, and so it is easy to draw an analogy between the waveguide process, and the process of recording a physical impulse response. Typically, for physical spaces, a speaker plays a signal at some location within the space, and a microphone reads the change in air pressure over time at another point in the space. The impulse response is found by deconvolving the input signal from the recorded signal. The analogue of this process within the waveguide mesh is to excite the mesh at one node, and to record the pressure at some output node at each time step, which is then deconvolved as before. Recording node pressures is simple, and deconvolution is a well-known technique. Injecting a source signal, however, requires careful engineering in order to maintain the physical plausibility and numerical robustness of the model. Source design has two main concerns: the method that is used to add the signal into the mesh, and the signal that is injected.</p>
<h4 id="input-node-update-method">Input Node Update Method</h4>
<p>Firstly, the input signal may be injected at a single node, or distributed across several <span class="citation" data-cites="jeong_source_2012">[<a href="#ref-jeong_source_2012">14</a>]</span>. It is complicated to calculate an appropriate distributed signal <span class="citation" data-cites="sakamoto_phase-error_2007">[<a href="#ref-sakamoto_phase-error_2007">15</a>]</span>, and so single-node sources are more common in the literature <span class="citation" data-cites="jeong_source_2012 lam_time_2012 sheaffer_physical_2014 murphy_source_2014 dimitrijevic_optimization_2015">[<a href="#ref-jeong_source_2012">14</a>], [<a href="#ref-lam_time_2012">16</a>]–[<a href="#ref-dimitrijevic_optimization_2015">19</a>]</span>.</p>
<p>There are two main options for updating the source node with the input signal. The first method, known as a <em>hard source</em>, simply overwrites the pressure value at the source node with that of the input signal. Hard sources are simple to implement, and ideally couple the input signal to the mesh, but also scatter any incident wave-fronts <span class="citation" data-cites="schneider_implementation_1998">[<a href="#ref-schneider_implementation_1998">20</a>]</span>. Although the initially radiated field is optimal, this spurious scattering is an undesirable artefact. Furthermore, the abrupt pressure discontinuity introduced by the hard source can cause more artefacts through the accumulation of numerical errors. For these reasons, hard sources are generally unsuitable for high-accuracy simulations.</p>
<p>The second method, the <em>soft source</em>, instead adds or superimposes the input signal on the standard mesh update equation. Soft sources obey the mesh update equations, and so do not suffer from the scattering problem. However, they do not couple the input signal to the mesh, so that the radiated wave front does not resemble the input signal. For input signals with DC components, soft sources can lead to <em>solution-growth</em>, in which the DC level of the entire simulation increases exponentially over time. This is not to do with numerical error or stability. Rather, the DC component suggests that the input signal is of infinite length, and that the source continues to create volume velocity for the duration of the simulation <span class="citation" data-cites="sheaffer_physically-constrained_2012">[<a href="#ref-sheaffer_physically-constrained_2012">21</a>]</span>. That is, the model is valid, but it is being used to model a physically-implausible situation. Solution-growth is unacceptable for modelling purposes. In all cases it creates an increasing DC component which is difficult to remove from the output. It also leads to a loss of precision in floating-point simulations, as intervals between floating-point numbers are larger for higher-magnitude numbers. The low-magnitude content of interest cannot be specified with high precision when it is superimposed on a high-magnitude DC component. In the worst case, the DC component will build up so much that the numerical representation “overflows”, placing an upper bound on the duration of the simulation. Some of the drawbacks of the soft source can be alleviated by carefully constructing the input signal, which will be discussed later.</p>
<p>Solution growth is not seen in hard source models, because the source node pressure is replaced by that of the input function. Therefore, at the source node, there is no addition of DC level. Unfortunately, rarefaction cannot occur at the source node, which can cause low-frequency oscillations instead. These oscillations are easier to remove than an increasing DC offset, and have less impact on precision.</p>
<p>A special case of the soft source is the <em>transparent source</em>, described in <span class="citation" data-cites="schneider_implementation_1998">[<a href="#ref-schneider_implementation_1998">20</a>]</span>. This method is the same as the soft source, but additionally subtracts the convolution of the mesh impulse response with the input signal from the input node. The resulting wave-front has the same characteristics as that produced by a hard source, with the additional benefit that incident wave-fronts are not scattered. The drawback of this technique is that the mesh impulse-response must be precomputed before the simulation can begin, which is achieved by running a separate (costly) waveguide mesh simulation. Once found, the mesh response can be used for any other simulation sharing the same mesh topology. Although the transparent source is complex to set up, its characteristics seem perfect. It behaves as if the input signal is perfectly coupled to the mesh, and there is no scattering problem. However, it retains the solution-growth issue of the general soft source.</p>
<p>The hard and soft source methods can be combined, in order to benefit from the characteristics of both methods. A <em>time-limited pulse</em> method is introduced in <span class="citation" data-cites="jeong_source_2012">[<a href="#ref-jeong_source_2012">14</a>]</span>, in which the source node starts as a hard source, and reverts to a soft source after a certain period of time has elapsed. The input signal is ideally coupled to the mesh for its duration, but thereafter the mesh can update as usual. As long as the source is positioned away from reflective boundaries, this solves the scattering issue. However, if the source is near to a reflective boundary, reflected wave-fronts might reach the source node before it has reverted to the standard update equation, scattering them. This input scheme has similar performance to the transparent source, with much reduced complexity, but it also shares a major drawback. If the input signal has a DC component, the time-limited hard source can still cause solution-growth <span class="citation" data-cites="sheaffer_physically-constrained_2012">[<a href="#ref-sheaffer_physically-constrained_2012">21</a>]</span>. In addition, if the nodes next to the source are not zero when the update equation switches from hard to soft, the pressure discontinuity introduced may introduce error which will propagate for the remainder of the simulation <span class="citation" data-cites="sheaffer_physical_2014">[<a href="#ref-sheaffer_physical_2014">17</a>]</span>.</p>
<p>On balance, it seems as though the transparent source is the optimum input method. Once the mesh impulse response has been computed, the update method itself is simple to implement, and does not carry any performance penalties. The only disadvantage is that the input function must be carefully designed to have no DC component, to avoid solution-growth. Unfortunately, overcoming this weakness is somewhat difficult, as will be shown in the following subsection.</p>
<h4 id="input-signal">Input Signal</h4>
<p>Of course, the input signal must be bounded in time, so that the simulation can end. The shorter the input signal, the fewer simulation steps must be computed, so shorter inputs are more efficient. If a single-sample Dirac-delta is used, all frequencies in the output bandwidth will be excited equally, and the output will not require deconvolution, which is another computational saving. It is plain that a short impulsive input is desirable in terms of efficiency. Unfortunately, impulsive signals have a DC component, which can cause solution-growth with soft, particularly transparent, sources.</p>
<p>The constraints of the input signal are, therefore, as follows: The signal shall have no DC component. It shall be as short as possible, to minimise the simulation time. It shall have a wide and flat passband, to increase the accuracy of the deconvolution. The time-compactness and bandwidth constraints are mutually exclusive, so in practice the input length must be chosen to balance bandwidth and calculation time.</p>
<p>Particular constraints of source signals are presented in greater detail in <span class="citation" data-cites="sheaffer_physical_2014">[<a href="#ref-sheaffer_physical_2014">17</a>]</span>, which puts forward an additional constraint, known as the <em>differentiation constraint</em>: The input signal shall be equal to the first time derivative of fluid emergence. Fluid emergence should start and end at zero, which in turn enforces a null DC component.</p>
<p>Some particular possibilities for the input signal are the <em>sine-modulated Gaussian pulse</em> <span class="citation" data-cites="jeong_source_2012">[<a href="#ref-jeong_source_2012">14</a>]</span>, and the <em>differentiated Gaussian pulse</em> and <em>Ricker wavelet</em> <span class="citation" data-cites="sheaffer_physical_2014">[<a href="#ref-sheaffer_physical_2014">17</a>]</span>. All of these signals satisfy the differentiation constraint and the length constraint. However, they all have non-flat pass-bands, as shown in fig. <a href="#fig:input_signal_info">4</a>. A final option is the <em>physically constrained source</em> (PCS) model presented in <span class="citation" data-cites="sheaffer_physical_2014">[<a href="#ref-sheaffer_physical_2014">17</a>]</span>. This method can be used to create input signals with pass-bands much flatter than those of the more conventional pulse and wavelet signals. PCS signals obey the differentiation constraint, have wide and flat passbands, and are short in time. They use soft-source injection, so will not cause scattering artefacts, and as they have no DC component, they should not introduce solution-growth. A PCS input signal seems like an obvious choice for this application.</p>
<figure>
<img src="images/kernel_properties.svg" alt="Figure 4: The time-domain and frequency-domain responses of some signals commonly used as FDTD excitations. All signals are shown with an upper cutoff of 0.2f_s. The pulse signals have their centre frequencies set to 0.1f_s. The PCS signal shown has a sampling rate of 10kHz, a mass of 25g, a low cutoff of 100Hz, and a Q of 0.7. It includes the injection filter, which means the signal shown could be injected like a soft source." id="fig:input_signal_info" /><figcaption>Figure 4: The time-domain and frequency-domain responses of some signals commonly used as FDTD excitations. All signals are shown with an upper cutoff of <span class="math inline">\(0.2f_s\)</span>. The pulse signals have their centre frequencies set to <span class="math inline">\(0.1f_s\)</span>. The PCS signal shown has a sampling rate of 10kHz, a mass of 25g, a low cutoff of 100Hz, and a Q of 0.7. It <em>includes</em> the injection filter, which means the signal shown could be injected like a soft source.</figcaption>
</figure>
<p>A test was devised to ensure that the source injection method did not cause solution-growth. A standard rectilinear waveguide mesh with a sampling frequency of 10kHz was set up within a cuboid room, measuring <span class="math inline">\(5.56 \times 3.97 \times 2.81\)</span> metres. A source was placed at (4.8, 2.18, 2.12), and a receiver at (4.7, 2.08, 2.02). The walls of the room were set to have a uniform broadband absorption of 0.006 (see the <a href="/wayverb/boundary.html">Boundary Modelling</a> section). “Transparent” input signals were created from a differentiated Gaussian pulse, a sine-modulated Gaussian pulse, and a Ricker wavelet, all of which were set to a centre frequency of 0.05 <span class="math inline">\(f_s\)</span>. A physically-constrained source signal was also generated, using parameters suggested in section V of <span class="citation" data-cites="sheaffer_physical_2014">[<a href="#ref-sheaffer_physical_2014">17</a>]</span>: a max-flat finite-impulse-response pulse-shaping filter kernel with 16 taps and centre frequency of 0.075 <span class="math inline">\(f_s\)</span> and magnitude 250μN was generated; it was passed through a mechanical shaping filter with radius 5cm, mass 25g, lower cutoff 100Hz, and resonance 0.7; then this signal was passed through an infinite-impulse-response <em>injection filter</em>, and used as a soft source. (These parameters are reproduced here to ensure that the test is repeatable, but a full discussion of their meaning is beyond the scope of this paper. The interested reader is directed to <span class="citation" data-cites="sheaffer_physical_2014">[<a href="#ref-sheaffer_physical_2014">17</a>]</span> or to the implementation of the physically-constrained source in the Wayverb repository.) Finally, the simulation was run for around 85,000 steps (less than the expected Sabine RT60 of the room) with each of the four sources, and the response at the receiver was recorded.</p>
<p>The results of the experiment are shown in fig. <a href="#fig:solution_growth_results">5</a>. The response of a transparent Dirac source (which has a strong DC component) is also shown. Solution growth can be seen in all the outputs. However, the magnitude of growth is different depending on the input signal. As expected, the Dirac signal exhibits the largest rate of growth, followed by the differentiated Gaussian, sine-modulated Gaussian, Ricker wavelet, and finally the PCS signal. All the sources with no DC component show significantly less solution-growth than the transparent Dirac source. The PCS has a much lower rate of growth than the alternatives. However, all inputs <em>do</em> show the effects of solution-growth.</p>
<figure>
<img src="images/solution_growth.svg" alt="Figure 5: Solution growth in the waveguide mesh with a selection of different inputs. Results are normalized so that the initial wave-fronts have the same magnitude. The overlays show the initial 500 samples of the response on the same scale, highlighting the different shapes of the excitation signals. The full signals are shown behind, with different amplitude scales. In the Dirac, Ricker, and PCS examples, the graphs appear filled-in due to high-frequency oscillations which increase in magnitude over time." id="fig:solution_growth_results" /><figcaption>Figure 5: Solution growth in the waveguide mesh with a selection of different inputs. Results are normalized so that the initial wave-fronts have the same magnitude. The overlays show the initial 500 samples of the response on the same scale, highlighting the different shapes of the excitation signals. The full signals are shown behind, with <em>different</em> amplitude scales. In the Dirac, Ricker, and PCS examples, the graphs appear “filled-in” due to high-frequency oscillations which increase in magnitude over time.</figcaption>
</figure>
<p>The solution-growth seen here only becomes prominent towards the end of the simulation, after around 60,000 steps. However, papers which propose countermeasures to the solution-growth problem generally only test their solutions up to 15,000 steps or so <span class="citation" data-cites="sheaffer_physical_2014 sheaffer_physically-constrained_2012 jeong_source_2012">[<a href="#ref-jeong_source_2012">14</a>], [<a href="#ref-sheaffer_physical_2014">17</a>], [<a href="#ref-sheaffer_physically-constrained_2012">21</a>]</span>. The results of testing the solution in <span class="citation" data-cites="dimitrijevic_optimization_2015">[<a href="#ref-dimitrijevic_optimization_2015">19</a>]</span> are not even presented. However, the experiments in <span class="citation" data-cites="botts_spectral_2014">[<a href="#ref-botts_spectral_2014">22</a>]</span> are run for 100,000 steps, exhibiting similar DC instability to the results presented here.</p>
<p>The reason for the solution-growth is not clear. In general, the problem is caused by repeated superposition of the DC level, which is reflected from boundaries. The waveguide has no inherent way of removing DC, so <em>any</em> small DC component will accumulate over time. If the original signal does not have a DC component, then the DC is being added from elsewhere. The most likely origin is numerical error in the waveguide mesh. The experiment above uses 32-bit single-precision floating-point to represent the pressure of mesh nodes, which is necessary because using double-precision would double the memory usage and halve the computational throughput. It is possible that error in these single-precision calculations manifests as a tiny DC component, which then multiplies as the simulation progresses.</p>
<p>The theory that low numerical-precision leads to solution-growth is reinforced by evidence given in <span class="citation" data-cites="botts_spectral_2014">[<a href="#ref-botts_spectral_2014">22</a>]</span>. This study shows that numerical error can perturb otherwise-stable simulations, causing gradual amplification. The solution proposed there is to conduct the entire simulation using double-precision floating-point, which would effectively delay rather than remove the effects of DC instability. As explained above, this approach is not practical in Wayverb.</p>
<p>Whatever the reason, it is clear that using a soft source generally causes a DC offset to accumulate, even when the input signal has no DC component. Soft sources may be suitable for shorter simulations. However, without running the simulation, it is impossible to know how much DC will accumulate, and whether or not it will remain within acceptable bounds. Therefore, in general, current forms of the soft source are not appropriate for arbitrary room simulation.</p>
<p>As an alternative to a soft source, Wayverb currently uses a hard source with a Dirac impulse as its input method. Though this still causes low-frequency error <span class="citation" data-cites="sheaffer_physical_2014">[<a href="#ref-sheaffer_physical_2014">17</a>]</span>, this error manifests as an oscillation rather than an exponential growth. The oscillation tends to be below the audible range, and therefore can be removed without affecting the perceived quality of the simulation. This removal is achieved with no phase modifications by transforming the signal into the frequency domain, smoothly attenuating the lowest frequencies, and then converting back to the time domain. This is the same filtering process used throughout Wayverb, described in detail in the <a href="/wayverb/ray_tracer.html">Ray Tracer</a> section. The main drawback of the hard source is its scattering characteristic. Though undesirable, this behaviour has a physical analogue: in a physical recording, reflected wave-fronts would be scattered from the speaker cabinet or starter pistol used to excite the space.</p>
<p>The creation of soft sources which do not cause solution growth is an important area for future research. Code for modelling soft sources remains in the Wayverb repository, to ease further development work in this area. If a better excitation method is discovered, it will be easy to replace the current source model with the improved one.</p>
<h2 id="implementation">Implementation</h2>
<p>Here, the final waveguide, as implemented in Wayverb, is described. Room acoustics papers tend not to discuss the set-up process for 3D waveguide meshes, so this process will be described in detail here.</p>
<h3 id="inner-and-outer-nodes">Inner and Outer Nodes</h3>
<p>Prerequisites for the simulation are: a 3D scene, made up of triangles, each of which has multi-band absorption coefficients; a source and receiver position within the scene; the speed of sound <span class="math inline">\(c\)</span> and acoustic impedance of air <span class="math inline">\(Z_0\)</span>, and the sampling frequency of the mesh <span class="math inline">\(f_s\)</span>. This sampling frequency may be derived from a maximum cutoff frequency and an oversampling coefficient.</p>
<p>The first step is to calculate the position of each node in the mesh. The inter-nodal spacing <span class="math inline">\(X\)</span> (that is, the spatial sampling period) is given by</p>
<p><span style="display: inline-block; position: relative; width: 100%"><span class="math display">\[X=\frac{c}{f_s\lambda} = \frac{c\sqrt{3}}{f_s}\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(8)</span></span> </p>
<p>where <span class="math inline">\(\lambda\)</span> is the Courant number, set to its maximum stable value. Now, the axis-aligned bounding box of the scene is found, and padded to exact multiples of the grid spacing along all axes. The exact padding is chosen so that one node will fall exactly at the receiver position, and so that there is room for an “outer layer” at least two nodes deep around the scene. This outer padding is to accommodate for boundary nodes, which will always be quantised to positions just outside the modelled enclosure. If the new padded bounding box has minimum and maximum corners at 3D points <span class="math inline">\(c_0\)</span> and <span class="math inline">\(c_1\)</span>, then the position of the node with integer indices <span class="math inline">\((i, j, k)\)</span> is given by <span class="math inline">\(c_0 + X(i, j, k)\)</span>. The number of nodes in each direction is given by <span class="math inline">\(\frac{c_1 - c_0}{X}\)</span>. The actual node positions are never computed and stored, because this would take a lot of memory. Instead, because the calculation is so cheap, they are recomputed from the node index, bounding box, and mesh spacing whenever they are needed.</p>
<p>Each node position must be checked, to determine whether it falls inside or outside the scene. The algorithm for checking whether a node is inside or outside is conceptually very simple: Follow a ray from the node position in a random direction chosen from a uniform distribution, until it leaves the scene bounding box. If the ray intersects with an odd number of surfaces, the point is inside; otherwise it is outside. There is an important special case to consider. Floating-point math is imprecise, so rays which “graze” the edge of a triangle may be falsely reported as intersecting or not-intersecting. This is especially problematic if the ray intersects an edge between two triangles, in which case zero, one, or two intersections may be registered. To solve this problem, the intersection test can return three states instead of two (“uncertain” as well as “definite intersection” and “definitely no intersection”). If the ray grazes any triangle, then “uncertain” is returned, and a new random ray is fired. The process then repeats until a ray with no grazing intersections is found. Note that this algorithm relies on ray-casting, which means that it can be accelerated using the voxel-based method discussed in the <a href="/wayverb/image_source.html">Image Source</a> section. All tests are carried out in parallel on the GPU, and the results are stored.</p>
<h3 id="boundary-node-classification">Boundary Node Classification</h3>
<p>The previous section described how to classify the “inner” nodes of an enclosure. However, the remaining nodes are not all “outside” the simulation: some are “boundary” nodes (see <a href="/wayverb/boundary.html">Boundary Modelling</a>). These boundary nodes must be found and classified.</p>
<p>Boundary nodes fall into three main categories, shown in fig. <a href="#fig:boundary_types">6</a>:</p>
<ul>
<li><strong>1D</strong> nodes are situated directly adjacent to a single inner node in one of the six axial directions.</li>
<li><strong>2D</strong> nodes are next to a single inner node in one of the twelve on-axis diagonal directions.</li>
<li><strong>3D</strong> nodes are next to a single inner node in one of the eight off-axis diagonal directions.</li>
</ul>
<figure>
<img src="images/boundary_types.svg" alt="Figure 6: A given node (represented by a large dot) is a boundary node if it is not an inner node, but there is an adjacent inner node at one of the locations shown by smaller dots." id="fig:boundary_types" /><figcaption>Figure 6: A given node (represented by a large dot) is a boundary node if it is <em>not</em> an inner node, but there is an adjacent inner node at one of the locations shown by smaller dots.</figcaption>
</figure>
<p>There is also a fourth category, known as <em>re-entrant</em> nodes, which are adjacent to two or more inner nodes. These nodes are special, in that they fall outside the enclosure (like boundary nodes) but are updated using the standard inner node equation. Re-entrant nodes are generally found on corners which face “into” the enclosed space.</p>
<p>The classification proceeds as follows: For a given node, if it is inside, return. Otherwise, check the node’s six axial neighbours. If one neighbour is inside, the node is a 1D boundary; if two neighbours are inside, the node is re-entrant; if no neighbours are inside the node remains unclassified. If the node is unclassified, check the twelve on-axis diagonal neighbours. If one neighbour is inside, the node is a 2D boundary; if two neighbours are inside, the node is re-entrant; if no neighbours are inside the node is still unclassified. Finally, check the eight off-axis diagonal neighbours. If one neighbour is inside, the node is a 3D boundary; if two neighbours are inside, the node is re-entrant; if no neighbours are inside, the node is an “outer” node and can be ignored for the remainder of the simulation. This classification process can of course be run in parallel on the GPU.</p>
<p>The classification is a little too involved to recompute regularly, so the results of the classification are cached. Each node stores its characteristics into a integer which behaves as a bitfield, allowing the characteristics to be stored in a compact form. Bits have the following significance:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">enum</span> : cl_int {
    id_none = <span class="dv">0</span>,
    id_inside = <span class="dv">1</span> &lt;&lt; <span class="dv">0</span>,
    id_nx = <span class="dv">1</span> &lt;&lt; <span class="dv">1</span>,
    id_px = <span class="dv">1</span> &lt;&lt; <span class="dv">2</span>,
    id_ny = <span class="dv">1</span> &lt;&lt; <span class="dv">3</span>,
    id_py = <span class="dv">1</span> &lt;&lt; <span class="dv">4</span>,
    id_nz = <span class="dv">1</span> &lt;&lt; <span class="dv">5</span>,
    id_pz = <span class="dv">1</span> &lt;&lt; <span class="dv">6</span>,
    id_reentrant = <span class="dv">1</span> &lt;&lt; <span class="dv">7</span>,
} node_type;</code></pre></div>
<p>The descriptor field for an inner node will be set to <code>id_inside</code>, and for a re-entrant node will be set to <code>id_reentrant</code>. Boundary nodes are described by setting bits equal to the direction of the adjacent inner node. A 1D node with an inner neighbour in the negative-x direction will have the descriptor <code>id_nx</code>, a 2D node with an inner neighbour on the positive-y-z diagonal will have the descriptor <code>id_py | id_pz</code> (where <code>|</code> is a bitwise-or operator), and a 3D node with an inner neighbour on the positive-x, negative-y, positive-z diagonal will have the descriptor <code>id_px | id_ny | id_pz</code>.</p>
<h3 id="boundary-behaviour-and-materials">Boundary Behaviour and Materials</h3>
<p>Each boundary node behaves as if it has an internal IIR filter. More precisely, 1D nodes have a single internal IIR filter, while 2D and 3D nodes have two and three internal filters respectively. To operate, these filters must reference filter coefficients which approximate the wall behaviour, and must also have dedicated storage for their filter delay lines.</p>
<p>First, the numbers of 1D, 2D, and 3D boundary nodes are counted. An array of single-filter delay lines is created, containing one delay line for each 1D node. The same is done for the 2D and 3D nodes, but each element in these arrays has storage for two and three filter delay lines respectively. Now, each boundary node is given a unique index which is used to reference an element in its corresponding filter memory array. These unique indices are simple to compute: for each node in the simulation, if it is 1D (or 2D, or 3D), increment a counter, and use the counter value as the unique index.</p>
<p>For each material in the scene, the Yule-Walker method is used to generate an IIR filter representing that material, resulting in an array of IIR filter coefficients. Each filter delay line is paired with an index field, which allows it to reference the filter coefficients which should be used when updating the filter.</p>
<p>The final step is to find which filter coefficients should be linked to which filter delay line. For 1D boundaries, the process is as follows: find the closest triangle to the node; find the material index of that triangle; get the node’s filter data entry; set the coefficient index field to be equal to the closest triangle’s material index. For 2D boundaries, adjacent 1D boundary nodes are checked, and their filter coefficient indices are used, which saves running further closest-triangle tests. For 3D boundaries, adjacent 1D <em>and</em> 2D nodes are checked.</p>
<p>At this point, all information required to run the simulation has been computed. Simulations may contain many millions of nodes, each with associated metadata, so this information must be stored in a way which minimises redundancy whilst still allowing for efficient queries. Wayverb’s memory layout scheme is shown in fig. <a href="#fig:memory_layout">7</a>.</p>
<figure>
<img src="images/memory_layout.svg" alt="Figure 7: Efficient memory usage is important in large-scale simulations such as those conducted by Wayverb. The waveguide storage scheme aims to minimise redundant duplication of data." id="fig:memory_layout" /><figcaption>Figure 7: Efficient memory usage is important in large-scale simulations such as those conducted by Wayverb. The waveguide storage scheme aims to minimise redundant duplication of data.</figcaption>
</figure>
<h3 id="running-the-simulation">Running the Simulation</h3>
<p>With node properties and boundary information set up, all that remains is to run the simulation itself. Two arrays of floating-point numbers are allocated, with length equal to the number of nodes in the simulation. These arrays represent the current and previous pressures at each node. The simulation is then run for a certain number of steps. In Wayverb the simulation length is found using the time of the final ray-traced histogram bin, divided by the mesh sampling frequency. In most cases this will lead to a sufficiently accurate duration estimate. However, in very large or irregularly-shaped rooms where few ray-receiver intersections are recorded, this may lead the waveguide simulation time to be underestimated. In this scenario, the simulation time can be found with greater accuracy by increasing the number of rays.</p>
<p>During a single step of the simulation, each node is updated. These updates occur in parallel, using the GPU. The “descriptor” field of each node is checked, and if it is <code>id_none</code> then the node is ignored. If the descriptor is <code>id_inside</code> or <code>id_reentrant</code> then the node is updated like a normal air node; that is, the “next” pressure of the node is equal to the sum of current axially-adjacent pressures divided by three, minus the previous pressure of the node. This is shown in the following equation, where <span class="math inline">\(i\)</span>, <span class="math inline">\(j\)</span>, and <span class="math inline">\(k\)</span> are spatial indices on the <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span> axes respectively, and <span class="math inline">\(n\)</span> is a time index.</p>
<p><span style="display: inline-block; position: relative; width: 100%"><span class="math display">\[p_{i,j,k}^{n+1} = \frac{1}{3}(p_{i-1,j,k}^n + p_{i+1,j,k}^n + p_{i,j-1,k}^n + p_{i,j+1,k}^n + p_{i,j,k-1}^n + p_{i,j,k+1}^n) - p_{i,j,k}^{n-1}\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(9)</span></span> </p>
<p>If the node is a boundary node, then it is instead updated according to the boundary update equations found in <span class="citation" data-cites="kowalczyk_modeling_2008">[<a href="#ref-kowalczyk_modeling_2008">23</a>]</span>.</p>
<p>The update equation references three points in time (<span class="math inline">\(n\)</span>, and <span class="math inline">\(n\pm 1\)</span>), which suggests that three arrays of node pressures required. That is, during update, the “previous” and “current” pressures are read from two arrays, and used to compute a value for the “next” pressure, which is then stored to a third array. A useful property of the update equations is that the “previous” pressure of each node is <em>only</em> used when updating that node. This means that the result of the update can be written back to the “previous” pressure array, instead of being written to an extra “next” array, which is a significant memory saving. For the following step of the simulation, the “current” and “previous” arrays are swapped. If the arrays are referenced through pointers, then this can be achieved by just swapping the pointers, which is much faster than swapping the actual array contents.</p>
<p>The simulation inputs and outputs are handled using generic callbacks. Before each step, a reference to the “current” pressure array is passed to a preprocessor callback, which may modify the pressure at any node. This architecture allows different source types to be implemented and swapped very easily. For example, hard and soft sources are just two different types of stateful callback. This also gives the option of excitations which span several nodes on the mesh. At the end of the step, the “current” pressure array is passed to the post-processor callback, which in general will append the value of a single node to an array, which can be retrieved at the end of the simulation. Again, the architecture is flexible, in that it allows for different receiver types, such as those discussed in <a href="/wayverb/microphone.html">Microphone Modelling</a>.</p>
<h2 id="summary">Summary</h2>
<p>A derivation for the waveguide mesh update formulae has been presented, along with the equations which relate the spatial sampling frequency, temporal sampling frequency, speed of sound, and number of dimensions. The K-DWM has been shown to be faster and more memory-efficient than the W-DWM, although both formulations exhibit dispersion error which limits the usable bandwidth of simulation results.</p>
<p>Different mesh topologies have been compared. The tetrahedral topology has the lowest density and fewest inter-node connections, so it is the optimal choice in terms of speed and memory consumption. Interpolated meshes are the most accurate and isotropic, but are more complicated to implement. For Wayverb, the rectilinear mesh was chosen, due to its relative simplicity, and because it was the only topology for which boundary formulations already existed.</p>
<p>Mesh input methods have been explored, and it has been shown that solution growth places a major design constraint upon mesh inputs. The literature suggests that the PCS is the optimal input signal. However, tests of five different non-hard inputs (including a PCS) showed that they all lead to solution growth, likely because of accumulated numerical error. The presence of solution growth means that pressure values may eventually overflow, invalidating results. To avoid this eventuality, Wayverb must use a hard source.</p>
<p>A simple procedure for building space-filling waveguide meshes with classified boundaries in arbitrary watertight manifold meshes has been presented. This is a novel contribution. Details relating to the efficient implementation of a DWM on graphics hardware have also been provided.</p>
<p>As shown, the DWM in Wayverb is obviously sub-optimal. Its topology is neither the fastest nor the most accurate, and its hard source causes scattering artefacts. Using a more efficient mesh topology would have required formulating an entirely new boundary modelling scheme, and using a soft source would have required development of a novel injection method. Such research, though useful, would have run counter to the specific research aims of this project. As noted in the <a href="/wayverb/context.html">Context</a> chapter, the purpose of Wayverb is primarily to create a useful tool for musicians, by surveying and combining existing techniques for room simulation. Further research into these issues, though important, would have precluded the completion of a usable simulation program. Of course, future research may reveal solutions to the problems identified over the course of this project. Improvements to Wayverb could then be made, based on these solutions.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-southern_spatial_2011">
<p>[1] A. Southern, S. Siltanen, and L. Savioja, “Spatial room impulse responses with a hybrid modeling method,” in <em>Audio Engineering Society Convention 130</em>, 2011. </p>
</div>
<div id="ref-smith_iii_equivalence_2004">
<p>[2] J. O. Smith III, “On the equivalence of the digital waveguide and finite difference time domain schemes,” <em>arXiv preprint physics/0407032</em>, 2004. </p>
</div>
<div id="ref-karjalainen_digital_2004">
<p>[3] M. Karjalainen and C. Erkut, “Digital waveguides versus finite difference structures: Equivalence and mixed modeling,” <em>EURASIP Journal on Applied Signal Processing</em>, vol. 2004, pp. 978–989, 2004. </p>
</div>
<div id="ref-smith_physical_1992">
<p>[4] J. O. Smith, “Physical modeling using digital waveguides,” <em>Computer music journal</em>, vol. 16, no. 4, pp. 74–91, 1992. </p>
</div>
<div id="ref-botts_integrating_2013">
<p>[5] J. Botts and L. Savioja, “Integrating finite difference schemes for scalar and vector wave equations,” in <em>2013 IEEE International Conference on Acoustics, Speech and Signal Processing</em>, 2013, pp. 171–175. </p>
</div>
<div id="ref-shelley_diffuse_2007">
<p>[6] S. B. Shelley, <em>Diffuse boundary modelling in the digital waveguide mesh</em>. University of York, 2007. </p>
</div>
<div id="ref-beeson_roomweaver:_2004">
<p>[7] M. J. Beeson and D. T. Murphy, “RoomWeaver: A digital waveguide mesh based room acoustics research tool,” in <em>Proc. COST G6 Conf. Digital Audio Effects (Naples, Italy, October 2004)</em>, 2004, pp. 268–73. </p>
</div>
<div id="ref-murphy_acoustic_2007">
<p>[8] D. Murphy, A. Kelloniemi, J. Mullen, and S. Shelley, “Acoustic modeling using the digital waveguide mesh,” <em>IEEE Signal Processing Magazine</em>, vol. 24, no. 2, pp. 55–66, 2007. </p>
</div>
<div id="ref-sheaffer_fdtd/k-dwm_2010">
<p>[9] J. Sheaffer and B. M. Fazenda, “FDTD/K-DWM simulation of 3D room acoustics on general purpose graphics hardware using compute unified device architecture (CUDA),” <em>Proc. Institute of Acoustics</em>, vol. 32, no. 5, 2010. </p>
</div>
<div id="ref-kowalczyk_room_2011">
<p>[10] K. Kowalczyk and M. van Walstijn, “Room acoustics simulation using 3-D compact explicit FDTD schemes,” <em>IEEE Transactions on Audio, Speech, and Language Processing</em>, vol. 19, no. 1, pp. 34–46, 2011. </p>
</div>
<div id="ref-van_duyne_3d_1996">
<p>[11] S. A. Van Duyne and J. O. Smith III, “The 3D tetrahedral digital waveguide mesh with musical applications,” in <em>Proceedings of the 1996 International Computer Music Conference</em>, 1996, pp. 9–16. </p>
</div>
<div id="ref-savioja_interpolated_2001">
<p>[12] L. Savioja and V. Välimäki, “Interpolated 3-D digital waveguide mesh with frequency warping,” in <em>Acoustics, Speech, and Signal Processing, 2001. Proceedings.(ICASSP’01). 2001 IEEE International Conference on</em>, 2001, vol. 5, pp. 3345–3348. </p>
</div>
<div id="ref-campos_computational_2005">
<p>[13] G. R. Campos and D. M. Howard, “On the computational efficiency of different waveguide mesh topologies for room acoustic simulation,” <em>IEEE Transactions on Speech and Audio Processing</em>, vol. 13, no. 5, pp. 1063–1072, 2005. </p>
</div>
<div id="ref-jeong_source_2012">
<p>[14] H. Jeong and Y. W. Lam, “Source implementation to eliminate low-frequency artifacts in finite difference time domain room acoustic simulation,” <em>The Journal of the Acoustical Society of America</em>, vol. 131, no. 1, pp. 258–268, 2012. </p>
</div>
<div id="ref-sakamoto_phase-error_2007">
<p>[15] S. Sakamoto, “Phase-error analysis of high-order finite difference time domain scheme and its influence on calculation results of impulse response in closed sound field,” <em>Acoustical Science and Technology</em>, vol. 28, no. 5, pp. 295–309, 2007. </p>
</div>
<div id="ref-lam_time_2012">
<p>[16] Y. W. Lam and J. A. Hargreaves, “Time domain modelling of room acoustics,” in <em>Proceedings of the Institute of Acoustics</em>, 2012. </p>
</div>
<div id="ref-sheaffer_physical_2014">
<p>[17] J. Sheaffer, M. van Walstijn, and B. Fazenda, “Physical and numerical constraints in source modeling for finite difference simulation of room acoustics,” <em>The Journal of the Acoustical Society of America</em>, vol. 135, no. 1, pp. 251–261, 2014. </p>
</div>
<div id="ref-murphy_source_2014">
<p>[18] D. T. Murphy, A. Southern, and L. Savioja, “Source excitation strategies for obtaining impulse responses in finite difference time domain room acoustics simulation,” <em>Applied Acoustics</em>, vol. 82, pp. 6–14, 2014. </p>
</div>
<div id="ref-dimitrijevic_optimization_2015">
<p>[19] B. Dimitrijevic, B. Nikolic, S. Aleksic, and N. Raicevic, “Optimization of Excitation in FDTD Method and Corresponding Source Modeling,” <em>RADIOENGINEERING</em>, vol. 24, no. 1, p. 11, 2015. </p>
</div>
<div id="ref-schneider_implementation_1998">
<p>[20] J. B. Schneider, C. L. Wagner, and S. L. Broschat, “Implementation of transparent sources embedded in acoustic finite-difference time-domain grids,” <em>The Journal of the Acoustical Society of America</em>, vol. 103, no. 1, pp. 136–142, 1998. </p>
</div>
<div id="ref-sheaffer_physically-constrained_2012">
<p>[21] J. Sheaffer, M. V. Walstijn, and B. M. Fazenda, “A physically-constrained source model for FDTD acoustic simulation,” in <em>Proc. of the 15th Int. Conference on Digital Audio Effects (DAFx-12)</em>, 2012. </p>
</div>
<div id="ref-botts_spectral_2014">
<p>[22] J. Botts and L. Savioja, “Spectral and pseudospectral properties of finite difference models used in audio and room acoustics,” <em>IEEE transactions on audio, speech, and language processing</em>, vol. 22, no. 9, pp. 1403–1412, 2014. </p>
</div>
<div id="ref-kowalczyk_modeling_2008">
<p>[23] K. Kowalczyk and M. van Walstijn, “Modeling frequency-dependent boundaries as digital impedance filters in FDTD and K-DWM room acoustics simulations,” <em>Journal of the Audio Engineering Society</em>, vol. 56, no. 7/8, pp. 569–583, 2008. </p>
</div>
</div>

        <nav id="prev_next_nav">
    
    
        
    
        
    
        
    
        
    
        
    
        
            
            
            
                <a href="/wayverb/ray_tracer.html" class="prev_page">Ray tracer</a>
            

            
            
            
                <a href="/wayverb/hybrid.html" class="next_page">Hybrid Model</a>
            
        
    
        
    
        
    
        
    
        
    
        
    
</nav>

    </div>
    <footer id="footer" class="wrapper alt">
    <div class="inner">
        <ul class="menu">
			<li>
                &copy; Reuben Thomas 2016. All rights reserved.
            </li>
            <li>
                Design: <a href="http://html5up.net">HTML5 UP</a>, modified by Reuben Thomas.
            </li>
		</ul>
	</div>
</footer>

<!-- Scripts -->
<script src="/wayverb/assets/js/jquery.min.js"></script>
<script src="/wayverb/assets/js/jquery.scrollex.min.js"></script>
<script src="/wayverb/assets/js/jquery.scrolly.min.js"></script>
<script src="/wayverb/assets/js/skel.min.js"></script>
<script src="/wayverb/assets/js/util.js"></script>
<!--[if lte IE 8]><script src="/wayverb/assets/js/ie/respond.min.js"></script><![endif]-->
<script src="/wayverb/assets/js/main.js"></script>

</div>
</body>
</html>
