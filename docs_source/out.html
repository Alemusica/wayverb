<h1 id="context" class="major">Context</h1>
<h2 id="overview">Overview</h2>
<p>Room acoustics algorithms fall into two main categories: <em>geometric</em>, and <em>wave-based</em> <span class="citation">[@southern_spatial_2011]</span>. Wave-based methods aim to numerically solve the wave equation, simulating the actual behaviour of sound waves within an enclosure. Geometric methods instead make some simplifying assumptions about the behaviour of sound waves, which result in faster but less accurate simulations. These assumptions generally ignore all wave properties of sound, choosing to model sound as independent <em>rays</em>, <em>particles</em>, or <em>phonons</em>.</p>
<p>The modelling of waves as particles has found great success in the field of computer graphics, where <em>ray-tracing</em> is used to simulate the reflections of light in a scene. The technique works well here because of the relatively high frequencies of the modelled waves. The wavelengths of these waves - the wavelengths of the visible spectrum - will generally be many times smaller than any surface in the scene being rendered, so wave phenomena have little or no effect.</p>
<p>The assumption that rays and waves are interchangeable falls down somewhat when modelling sound. Here, the wavelengths range from 17m to 0.017m for the frequency range 20Hz to 20KHz, so while the simulation may be accurate at high frequencies, at low frequencies the wavelength is of the same order as the wall surfaces in the scene. Failure to take wave effects such as interference and diffraction into account at these frequencies therefore results in noticeable approximation error <span class="citation">[@savioja_overview_2015]</span>.</p>
<p>In many cases, some inaccuracy is an acceptable (or even necessary) trade-off. Wave-modelling is so computationally expensive that using it to simulate a large scene over a broad spectrum could take weeks on consumer hardware. This leaves geometric methods as the only viable alternative. Though wave-modelling been studied for some time <span class="citation">[@smith_physical_1992]</span>, and even applied to small acoustic simulations in consumer devices (such as the Yamaha VL1 keyboard), it is only recently, as computers have become more powerful, that these techniques have been seriously considered for room acoustics simulation.</p>
<p>Given that wave-based methods are accurate, but become more expensive at higher frequencies, and that geometric methods are inexpensive, but become less accurate at lower frequencies, it is natural to combine the two models in a way that takes advantage of the desirable characteristics of each. That is, by using wave-modelling for low-frequency content, and geometric methods for high-frequency content, simulations may be produced which are accurate across the entire spectrum, without incurring massive computational costs.</p>
<h2 id="characteristics-of-simulation-methods">Characteristics of Simulation Methods</h2>
<p>A short review of simulation methods will be given here. For a detailed survey of methods used in room acoustics, see <span class="citation">@svensson_computational_2002</span>.</p>
<div class="figure">
<img src="images/simulation_techniques.png" alt="An overview of different acoustic simulation methods, grouped by category." />
<p class="caption">An overview of different acoustic simulation methods, grouped by category.</p>
</div>
<h3 id="geometric">Geometric</h3>
<p>Geometric methods can largely be grouped into two categories: <em>stochastic</em> and <em>deterministic</em>.</p>
<p>Stochastic methods are generally based on statistical approximation via some kind of Monte Carlo algorithm. They may be based directly on reflection paths, using <em>ray tracing</em> or <em>beam tracing</em>, in which rays or beams are considered to transport acoustic energy around the scene. Alternatively, they may use a surface-based technique, such as <em>acoustic radiance transfer</em> (ART), in which surfaces are used as intermediate stores of acoustic energy.</p>
<p>These techniques are inherently approximate. They aim to randomly probe the problem space repeatedly, combining the results from multiple samples so that they converge upon the impulse response for a scene. They can be tuned easily, as quality can be traded-off against speed simply by adjusting the number of samples taken. Surface-based methods, especially, are suited to real-time simulations (i.e. interactive, where the listener position can change), as the calculation occurs in several passes, only the last of which involves the receiver object. This means that early passes can be computed and cached, and only the final pass must be recomputed if the receiver position changes.</p>
<p>The main deterministic method is the <em>image source</em> method, which is designed to calculate the exact reflection paths between a source and a receiver. For shoebox-shaped rooms, and perfectly rigid surfaces, it is able to produce an exact solution to the wave equation. However, by its nature, it can only model specular (perfect) reflections, ignoring diffuse and diffracted components. For this reason, it is inexact for arbitrary enclosures, and unsuitable for calculating reverb tails, which are predominantly diffuse. The technique also becomes very expensive beyond low orders of reflection. The naive implementation reflects the sound source against all surfaces in the scene, resulting in a set of <em>image sources</em>. Then, each of these image sources is itself reflected against all surfaces. For high orders of reflection, the required number of calculations quickly becomes impractical. For these reasons, the image source method is only suitable for early reflections, and is generally combined with a stochastic method to find the late part of an impulse response.</p>
<p>For a detailed reference on geometric acoustic methods, see <span class="citation">@savioja_overview_2015</span>.</p>
<h3 id="wave-based">Wave-based</h3>
<p>The main advantage of wave-based methods is that they inherently account for wave effects like diffraction and interference <span class="citation">[@shelley_diffuse_2007]</span>, while geometric methods do not. This means that they are capable of accurately simulating the low-frequency component of a room impulse-response, where constructive and destructive wave interference form <em>room modes</em>. Room modes have the effect of amplifying and attenuating specific frequencies in the room impulse response, and produce much of the subjective sonic 'colour' or 'character' of a room. Reproducing these room modes is therefore vital for evaluating the acoustics of rooms such as concert halls and recording studios, or when producing musically pleasing reverbs.</p>
<p>Wave-based methods may be derived from the <em>Finite Element Method</em> (FEM), <em>Boundary Element Method</em> (BEM) or <em>Finite-Difference Time-Domain</em> (FDTD) method. The FEM and BEM may be known together as <em>element methods</em>.</p>
<p>The FEM is an iterative numerical method for finding natural resonances of a bounded enclosure. It models the air pressure inside the enclosure using a grid of interconnected nodes, each of which represents a mechanical system with a single degree of freedom. The interconnectedness of the nodes leads to a set of simultaneous equations, which can be solved for displacement at each node, and then the solved equations can be used to calculate pressure values at certain elements. The BEM is similar, but models nodes on the surface of the enclosure, instead of within it. This in turn allows it to model unbounded spaces. <span class="citation">[@murphy_digital_2000]</span></p>
<p>The FDTD method works by dividing the space to be modelled into a regular grid, and computing changes in some quantity at each grid point over time. The formula used to update each grid point, along with the topology of the grid, may be varied depending on the accuracy, efficiency, and complexity of required by the application. FDTD methods are generally applied to problems in electromagnetics, but a subclass of the FDTD method known as the <em>Digital Waveguide Mesh</em> (DWM) is often used for solving acoustics problems.</p>
<p>The FDTD shares some characteristics with the element methods. They all become rapidly more computationally expensive as the maximum output frequency increases <span class="citation">[@valimaki_fifty_2012]</span>. They also share the problem of discretisation or quantisation, in which details of the modelled room can only be resolved to the same accuracy as the spatial sampling period. If a large inter-element spacing is used, details of the room shape will be lost, whereas a small spacing will greatly increase the computational load.</p>
<p>The FDTD method has one major advantage over element methods: it is run directly in the time domain, rather than producing frequency-domain results, which in turn affords a much simpler implementation.</p>
<p>The main disadvantage of the FDTD method is that it is susceptible to <em>numerical dispersion</em>, in which wave components travel at different speeds depending on their frequency and direction, especially at high frequencies. Several techniques exist to reduce this error, such as oversampling the mesh <span class="citation">[@campos_computational_2005]</span>, using different mesh topologies <span class="citation">[@savioja_reduction_1999; @van_duyne_tetrahedral_1995]</span>, and post-processing the simulation output <span class="citation">[@savioja_interpolated_2001]</span>. Oversampling further increases the computational load of the simulation, while using different topologies and post-processing both introduce additional complexity.</p>
<p>Despite its drawbacks, the FDTD method is generally preferred for room acoustics simulation <span class="citation">[@valimaki_fifty_2012]</span>, probably due to its straightforward implementation, intuitive behaviour, and its ability to directly produce time-domain impulse responses.</p>
<h2 id="existing-software">Existing Software</h2>
<p>Searching online and in the literature uncovers a handful of programs for acoustic simulation (this is not an exhaustive list, but it is felt to be representative):</p>
<table>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Type</th>
<th align="left">Availability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Odeon <span class="citation">[@_odeon_2016]</span></td>
<td align="left">Geometric</td>
<td align="left">Commercial</td>
</tr>
<tr class="even">
<td align="left">CATT-Acoustic <span class="citation">[@_catt-acoustic_2016]</span></td>
<td align="left">Geometric</td>
<td align="left">Commercial</td>
</tr>
<tr class="odd">
<td align="left">Olive Tree Lab <span class="citation">[@_otl_2016]</span></td>
<td align="left">Geometric</td>
<td align="left">Commercial</td>
</tr>
<tr class="even">
<td align="left">EASE <span class="citation">[@_ease_2016]</span></td>
<td align="left">Geometric</td>
<td align="left">Commercial</td>
</tr>
<tr class="odd">
<td align="left">Auratorium <span class="citation">[@_audioborn_2016]</span></td>
<td align="left">Geometric</td>
<td align="left">Commercial</td>
</tr>
<tr class="even">
<td align="left">RAVEN <span class="citation">[@schroder_raven:_2011]</span></td>
<td align="left">Geometric</td>
<td align="left">None</td>
</tr>
<tr class="odd">
<td align="left">RoomWeaver <span class="citation">[@beeson_roomweaver:_2004]</span></td>
<td align="left">Waveguide</td>
<td align="left">None</td>
</tr>
<tr class="even">
<td align="left">EAR <span class="citation">[@_ear_2016]</span></td>
<td align="left">Geometric</td>
<td align="left">Free</td>
</tr>
<tr class="odd">
<td align="left">PachydermAcoustic <span class="citation">[@_pachyderm_2016]</span></td>
<td align="left">Geometric</td>
<td align="left">Free</td>
</tr>
<tr class="even">
<td align="left">Parallel FDTD <span class="citation">[@_parallelfdtd_2016]</span></td>
<td align="left">Waveguide</td>
<td align="left">Free</td>
</tr>
<tr class="odd">
<td align="left">i-Simpa <span class="citation">[@_i-simpa_2016]</span></td>
<td align="left">Geometric, extensible</td>
<td align="left">Free</td>
</tr>
</tbody>
</table>
<p>All commercial acoustics programs found use geometric techniques, probably because they are fast to run, and can often be implemented to run interactively, in real-time. However, low-frequency performance is a known issue with these programs. For example, the FAQ page for the Odeon software <span class="citation">[@_odeon_2016-1]</span> notes that:</p>
<blockquote>
<p>For Odeon simulations as with real measurements, the source and receiver should be at least 1/4th wave length from the walls. But at the very lowest resonance of the room the level can change a lot from position to position without Odeon being able to predict it. For investigation of low frequency behavior (resonances), indeed Odeon is not the tool.</p>
</blockquote>
<p>Clearly there is a need for acoustics software which can accurately predict low frequency behaviour. However, such software seems to be somewhat rarer than geometric acoustics software. Of the two wave-modelling programs listed, only one is generally available, which must additionally be run from Python or Matlab scripts. This is a good approach for research software, but would probably not be straightforward for users with limited programming experience.</p>
<p>As of December 2016, it appears that no generally-available (commercially or otherwise) piece of software has taken the approach of combining wave-modelling and geometric methods, although this technique is well-known in the literature <span class="citation">[@southern_hybrid_2013; @aretz_combined_2009; @murphy_hybrid_2008; @southern_room_2013; @vorlander_simulation_2009; @southern_spatial_2011]</span>.</p>
<h2 id="research-aims">Research Aims</h2>
<p>With all this in mind, it appears that there is a requirement for a program which combines geometric and wave-based methods to produce simulations which are accurate across the audible spectrum. Rather than focussing on performance, or interactive simulation (which is already implemented in the commercial software above), such a program should strive towards accuracy first, and performance second. To be useful to end-users, the program should have a graphical interface, though a scripting or library interface might be provided for research purposes. Finally, the program would ideally be free and open-source, to maximise adoption and to aid future research and collaboration. The goal of the Wayverb project was to produce a program which satisfied these requirements.</p>
<h2 id="strategy">Strategy</h2>
<h3 id="chosen-simulation-techniques">Chosen Simulation Techniques</h3>
<p>As the image-source method is well-suited to finding early reflections, and stochastic methods are reasonably accurate at computing the more diffuse late reflections, it made sense to combine these two methods for high-frequency simulation. Specifically, a simple ray tracing method was chosen over a phonon- or surface-based method for the late-reflection simulation, for two reasons. Firstly, ray tracing is broadly discussed in the literature <span class="citation">[@krokstad_calculating_1968; @kuttruff_room_2009; @vorlander_auralization:_2007; @schroder_physically_2011; @alpkocak_computing_2010]</span>, so would not require a great deal of experimentation to implement. Secondly, ray tracing has the property of being an <em>embarrassingly parallel</em> algorithm, because each individual ray can be simulated entirely independently, without requiring communication or synchronisation. By running the algorithm on graphics hardware, which is inherently parallel, all rays could be simulated in one go, yielding much greater performance than processing each ray sequentially.</p>
<p>A logistical reason for choosing the image-source and ray tracing solution for high-frequency modelling was that the author had previously implemented such a system for an undergraduate project. It was hoped that much of the code from that project could be re-used, but it transpired that much of the code was unsuitable or incorrect (!), so that the majority was completely re-written. The author was, however, able to re-use much of the knowledge and experience gained from the previous project, which would not have been possible if a completely new stochastic method had been introduced.</p>
<p>For low-frequency simulation, a FDTD-based DWM model was chosen. There is a great deal of writing on this method <span class="citation">[@van_duyne_3d_1996; @savioja_interpolated_2014; @kowalczyk_room_2011; @campos_computational_2005; @murphy_digital_2000]</span>, it is relatively simple to implement, and shares with ray tracing the characteristic of being embarrassingly parallel. Each element in the waveguide mesh can be updated individually and simultaneously, which it was hoped would yield performance benefits.</p>
<p>An in-depth description of the algorithms implemented will be given in the <a href="%7B%7B%20site.baseurl%20%7D%7D%7B%%20link%20image_source.md%20%%7D">Image-Source</a>, <a href="%7B%7B%20site.baseurl%20%7D%7D%7B%%20link%20ray_tracer.md%20%%7D">Ray Tracer</a>, and <a href="%7B%7B%20site.baseurl%20%7D%7D%7B%%20link%20waveguide.md%20%%7D">Waveguide</a> sections.</p>
<div class="figure">
<img src="images/regions.png" alt="The structure of a simulated impulse response." />
<p class="caption">The structure of a simulated impulse response.</p>
</div>
<p>Deciding on the simulation techniques led to three questions:</p>
<ul>
<li>To produce a final output, the three simulations must be automatically mixed in some way. How can this be done?</li>
<li>Binaural simulation requires some method for direction- and frequency-dependent attenuation at the receiver. How can receivers with polar patterns other than omnidirectional be modelled consistently in all three simulation methods?</li>
<li>The reverb time and character depends heavily on the nature of the reflective surfaces in the scene. How can frequency-dependent reflective boundaries be modelled consistently in all methods?</li>
</ul>
<p>These questions will be discussed in the <a href="%7B%7B%20site.baseurl%20%7D%7D%7B%%20link%20hybrid.md%20%%7D">Hybrid</a>, <a href="%7B%7B%20site.baseurl%20%7D%7D%7B%%20link%20microphone.md%20%%7D">Microphone Modelling</a>, and <a href="%7B%7B%20site.baseurl%20%7D%7D%7B%%20link%20boundary.md%20%%7D">Boundary Modelling</a> sections respectively.</p>
<h3 id="chosen-technology">Chosen Technology</h3>
<p>The programming language chosen was C++. For acceptable performance in numerical computing, a low-level language is required, and for rapid prototyping, high-level abstractions are necessary. C++ delivers on both of these requirements, for the most part, although its fundamentally unsafe memory model does introduce a class of bugs which don't really exist in languages with garbage collection, borrow checking, or some other safety mechanism.</p>
<p>OpenCL was chosen for implementing the most parallel parts of the simulation. The OpenCL framework allows a single source file to be written, in a C-like language, which can target either standard <em>central processing units</em> (CPUs), or highly parallel <em>graphics processing units</em> (GPUs). The main alternative to OpenCL is CUDA, which additionally can compile C++ code, but which can only target Nvidia hardware. OpenCL was chosen as it would allow the final program to be run on a wider variety of systems, with fewer limitations on their graphics hardware.</p>
<p>The only deployment target was macOS. This was mainly to ease development, as maintaining software across multiple platforms is often time-consuming. macOS also tends to have support for newer C++ language features than Windows. Visual Studio 2015 for Windows still doesn't support all of the C++11 language features <span class="citation">[@_visual_2016]</span>, while the Clang compiler used by macOS has supported newer C++14 features since version 3.4 <span class="citation">[@_clang_2016]</span>, released in May 2014 <span class="citation">[@_download_2016]</span>. Targeting a single platform avoids the need to use only the lowest common denominator of language features. As far as possible, the languages and libraries have been selected to be portable if the decision to support other platforms is made in the future. Once Windows fully supports C++14, it should be possible to port the program with a minimum of effort.</p>
<p>The following additional libraries were used to speed development. They are all open-source and freely available.</p>
<ul>
<li><em>GLM:</em> Provides vector and matrix primitives and operations, primarily designed for use in 3D graphics software, but which is useful for any program that will deal with 3D space.</li>
<li><em>Assimp:</em> Used for loading and saving 3D model files in a wide array of formats, with a consistent interface for querying loaded files.</li>
<li><em>FFTW3:</em> Provides Fast Fourier Transform routines. Used mainly for filtering and convolution.</li>
<li><em>Libsndfile:</em> Used for loading and saving audio files, specifically for saving simulation results.</li>
<li><em>Libsamplerate:</em> Provides high-quality sample-rate-conversion routines. Waveguide simulations are often run at a relatively low sample-rate, which must then be adjusted.</li>
<li><em>Gtest:</em> A unit-testing framework, used to validate small individual parts of the program, and ensure that changes to one module don't cause breakage elsewhere.</li>
<li><em>Cereal:</em> Serializes data to and from files. Used for saving program configuration options.</li>
<li><em>ITPP:</em> A scientific computing library. Used for its implementation of the Yule-Walker method for estimating filter coefficients for a given magnitude response.</li>
<li><em>JUCE:</em> Provides a framework for building graphical applications in C++. Used for the final application.</li>
</ul>
<p>The project uses Cmake to configure its build, and to automatically download project dependencies. Python and Octave were used for running and automating tests and generating graphs.</p>
<p>This documentation is written in Markdown, and compiled to html and to pdf using Pandoc. The project website is generated with Jekyll.</p>
